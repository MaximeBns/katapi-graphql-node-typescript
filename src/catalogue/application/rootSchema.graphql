type Query {
    recupererLesProduits(filter: ProduitFilter): ResultatListeDeProduit
    recupererLeProduit(id:String!): ResultatProduit
    recupererLesCommandes: ResultatListeCommande
    recupererLaCommande(id: String!): ResultatCommande
}

type Mutation {
    sauvegarderProduit(produit: ProduitInput): Produit
    sauvegarderCommande(commande: CommandeInput): Commande
}

union ResultatListeDeProduit = ListeDeProduits | InternalServerError | BadRequestError | NotFoundError
union ResultatListeProduit = ListeDeProduits | ProduitNonTrouve
union ResultatProduit = Produit | ProduitNonTrouve
union ResultatListeCommande = ListeCommande | CommandeNonTrouvee
union ResultatCommande = Commande | CommandeNonTrouvee

# PRODUIT
type Produit {
    id: String!
    nom: String!
    prix: Float!
    poids: Float!
}

type ProduitNonTrouve {
    id: String!
    message: String
}

# LISTE DE PRODUITS
type ProduitEdge {
    node: Produit
    cursor: String
}

type PageInfo {
    startCursor: String
    hasNextPage: Boolean
}

type ListeDeProduits {
    totalCount: String
    edges: [ProduitEdge]
    pageInfo: PageInfo
}

input Compare {
    sign: Sign!
    than: Float!
}

enum Sign {
    GREATER
    LOWER
    LOWER_THAN_OR_EQUAL
    GREATER_THAN_OR_EQUAL_TO
}

enum OrderType {
    ASC
    DESC
}

# LISTE COMMANDE
type ListeCommande {
    commandes: [Commande]
}

type CommandeNonTrouvee {
    id: String!
    message: String
}

type Commande {
    id: String!
    statut: StatutDemande!
    elements: [ElementCommande]!
    fraisDePort: Float!
    montantTotal: Float!
    poids: Float!
}

enum StatutDemande {
    EN_COURS
    PAYEE
    ANNULEE
}

type ElementCommande {
    produit: ResultatProduit!
    quantite: Int!
}

# INPUT
input ProduitInput {
    nom: String!
    prix: Float!
    poids: Float!
}

input CommandeInput {
    elements: [ElementCommandeInput]!
}

input ElementCommandeInput {
    idProduit: String!
    quantite: Int!
}

input ProduitFilter {
    by: String! = "name"
    order: OrderType! = "ASC"
    compare: Compare
    contains: String
    first: Int
    afterCursor: String
}

# ERROR HANDLING

interface Error {
    code: Int!
    message: String!
}

type BadRequestError implements Error{
    code: Int!
    message: String!
}

type InternalServerError implements Error{
    code: Int!
    message: String!
}

type NotFoundError implements Error{
    code: Int!
    message: String!
}
